{
  "hash": "0126eb279484ee46bff4393e007267c8",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 1c\"\ndate: January 13, 2024\ndate-modified: \"last-modified\"\ntoc: true\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n  message: false\n---\n\n\n# Emerging Hot Spot Analysis: sfdep methods\n\nEmerging Hot Spot Analysis (EHSA) is a spatio-temporal analysis method for revealing and describing how hot spot and cold spot areas evolve over time. The analysis consist of four main steps:\n\n-   Building a space-time cube,\n\n-   Calculating Getis-Ord local Gi\\* statistic for each bin by using an FDR correction,\n\n-   Evaluating these hot and cold spot trends by using Mann-Kendall trend test,\n\n-   Categorising each study area location by referring to the resultant trend z-score and p-value for each location with data, and with the hot spot z-score and p-value for each bin.\n\n# Data Loading and Prep\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, dplyr , \n               sf, lubridate,plotly,\n               tmap, spdep, sfdep)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nACLED_MMR <- read_csv(\"data/MMR.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmmr_shp_mimu_2 <-  st_read(dsn = \"data/geospatial3\",  \n                  layer = \"mmr_polbnda_adm2_250k_mimu\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `mmr_polbnda_adm2_250k_mimu' from data source \n  `C:\\imranmi\\ISSS608-VAA\\Take-home-ex\\Take-home-Ex1c\\data\\geospatial3' \n  using driver `ESRI Shapefile'\nSimple feature collection with 80 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmmr_shp_mimu_1 <-  st_read(dsn = \"data/geospatial3\",  \n                  layer = \"mmr_polbnda2_adm1_250k_mimu_1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `mmr_polbnda2_adm1_250k_mimu_1' from data source \n  `C:\\imranmi\\ISSS608-VAA\\Take-home-ex\\Take-home-Ex1c\\data\\geospatial3' \n  using driver `ESRI Shapefile'\nSimple feature collection with 18 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nACLED_MMR_1 <- ACLED_MMR %>%\n  mutate(admin1 = case_when(\n    admin1 == \"Bago-East\" ~ \"Bago (East)\",\n    admin1 == \"Bago-West\" ~ \"Bago (West)\",\n    admin1 == \"Shan-North\" ~ \"Shan (North)\",\n    admin1 == \"Shan-South\" ~ \"Shan (South)\",\n    admin1 == \"Shan-East\" ~ \"Shan (East)\",\n    TRUE ~ as.character(admin1)\n  ))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nACLED_MMR_1 <- ACLED_MMR_1 %>%\n  mutate(admin2 = case_when(\n    admin2 == \"Yangon-East\" ~ \"Yangon (East)\",\n    admin2 == \"Yangon-West\" ~ \"Yangon (West)\",\n    admin2 == \"Yangon-North\" ~ \"Yangon (North)\",\n    admin2 == \"Yangon-South\" ~ \"Yangon (South)\",\n    admin2 == \"Mong Pawk (Wa SAD)\" ~ \"Tachileik\",\n    admin2 == \"Nay Pyi Taw\" ~ \"Det Khi Na\",\n    admin2 == \"Yangon\" ~ \"Yangon (West)\",\n    TRUE ~ as.character(admin2)\n  ))\n```\n:::\n\n\n# Creating a Time Series Cube\n\nIn the code chunk below, [`spacetime()`](https://sfdep.josiahparry.com/reference/spacetime.html) of sfdep is used to create an spatio-temporal cube.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC <- read_csv(\"data/aspatial/Hunan_GDPPC.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial4\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\imranmi\\ISSS608-VAA\\Take-home-ex\\Take-home-Ex1c\\data\\geospatial4' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(GDPPC)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC_st <- spacetime(GDPPC, hunan,\n                      .loc_col = \"County\",\n                      .time_col = \"Year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(GDPPC_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Renaming the column names\n\nloc_col identifier needs to be the same name for both data and shape file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBattles_admin1 <- ACLED_MMR_1 %>%\n    group_by(year, admin1) %>%\n    filter(event_type == \"Battles\") %>%\n    summarise(Incidents = n()) %>%\n    ungroup() %>%\n    rename(ST = admin1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbattles_spacial1 <- spacetime(Battles_admin1, mmr_shp_mimu_1,\n                      .loc_col = \"ST\",\n                      .time_col = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(battles_spacial1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThis is due to some years having zero incident, this needs to be populated as zero, all district names have to be accounted for, for each year\n\nTrying with a smaller set, but manually inserting zero for each year, in each district\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBattles_admin1_2124 <- read_csv(\"data/Battles_admin1_2124.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbattles_test2 <- spacetime(Battles_admin1_2124, mmr_shp_mimu_1,\n                   .loc_col = \"ST\",\n                   .time_col = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(battles_test2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nconversion to space time object is successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(battles_test2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"spacetime\"   \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n```\n:::\n:::\n\n\n## Data preparation steps for all Battles data (2011-2023)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Battles_admin2 <- ACLED_MMR_1 %>%\n    #filter(year != 2024, year != 2010, event_type == \"Battles\") %>%\n    #group_by(year, admin2) %>%\n    #summarise(Incidents = n(), .groups = 'drop') %>%\n    #rename(DT = admin2)\n```\n:::\n\n\n## Data preparation steps for all Battles data (2018-2023)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBattles_admin2 <- ACLED_MMR_1 %>%\n    filter(year >= 2021, year <= 2023, event_type == \"Battles\") %>%\n    group_by(year, admin2) %>%\n    summarise(Incidents = n(), .groups = 'drop') %>%\n    rename(DT = admin2)\n```\n:::\n\n\ncreating an empty data set with all district names and years populated\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all unique years from the incidents data\nall_years <- unique(Battles_admin2$year)\n\n# Get all unique state names from the shapefile\nall_districts <- unique(mmr_shp_mimu_2$DT)\n\n# Create all combinations of years and states\ncomplete_combinations <- expand.grid(year = all_years, DT = all_districts)\n```\n:::\n\n\nJoining the filtered Incident data with the empty \"complete\" data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join the complete combinations with the battles data\n\nbattles_complete <- left_join(complete_combinations, Battles_admin2, by = c(\"year\", \"DT\"))\n```\n:::\n\n\nReplacing all NA values with zero\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace NA with zero for the incidents where there were no incidents\nbattles_complete$Incidents[is.na(battles_complete$Incidents)] <- 0\n```\n:::\n\n\nUsing `spacetime ()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBattles_complete_st <- spacetime(battles_complete, mmr_shp_mimu_2,\n                   .loc_col = \"DT\",\n                   .time_col = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(Battles_complete_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(Battles_complete_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"spacetime\"  \"data.frame\"\n```\n:::\n:::\n\n\nConversion to spacetime object is successful.\n\n## Computing Gi\\*\n\nNext, we will compute the local Gi\\* statistics.\n\n### Deriving the spatial weights\n\nThe code chunk below will be used to identify neighbors and to derive an inverse distance weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIncidents_nb <- Battles_complete_st %>%\n  activate(\"geometry\") %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wt = st_inverse_distance(nb, geometry,\n                                  scale = 1,\n                                  alpha = 1),\n         .before = 1) %>%\n  set_nbs(\"nb\") %>%\n  set_wts(\"wt\")\n```\n:::\n\n\n::: callout-note\n## Note\n\n-   `activate()` of dplyr package is used to activate the geometry context\n\n-   `mutate()` of dplyr package is used to create two new columns *nb* and *wt*.\n\n-   Then we will activate the data context again and copy over the nb and wt columns to each time-slice using `set_nbs()` and `set_wts()`\n\n    -   row order is very important so do not rearrange the observations after using `set_nbs()` or `set_wts()`.\n:::\n\nNote that this dataset now has neighbors and weights for each time-slice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(Incidents_nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year        DT Incidents                     nb\n1  2021  Hinthada         1 1, 3, 5, 9, 10, 34, 78\n4  2021   Labutta         3                2, 4, 6\n7  2021    Maubin         1  1, 3, 4, 5, 6, 78, 79\n10 2021 Myaungmya         0          2, 3, 4, 5, 6\n13 2021   Pathein        10         1, 3, 4, 5, 34\n16 2021    Pyapon         1         2, 3, 4, 6, 79\n                                                                                          wt\n1  0.000000000, 0.008718330, 0.007176059, 0.010534826, 0.014598797, 0.011601884, 0.008842690\n4                                                         0.00000000, 0.03041780, 0.02727816\n7         0.00871833, 0.00000000, 0.01715433, 0.01050111, 0.01149078, 0.01579960, 0.00953857\n10                                0.03041780, 0.01715433, 0.00000000, 0.01962856, 0.01496581\n13                           0.007176059, 0.010501109, 0.019628563, 0.000000000, 0.005359393\n16                           0.027278158, 0.011490779, 0.014965812, 0.000000000, 0.008427111\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of checking if 'nb' is correctly formatted after its computation\n#if (!inherits(Incidents_nb$nb[[1]], \"nb\")) {\n  #stop(\"nb is not a valid neighbors list. Check its computation.\")\n#}\n```\n:::\n\n\n## Computing Gi\\*\n\nWe can use these new columns to manually calculate the local Gi\\* for each location. We can do this by grouping by *Year* and using `local_gstar_perm()` of sfdep package. After which, we `use unnest()` to unnest *gi_star* column of the newly created *gi_starts* data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC_nb <- GDPPC_st %>%\n  activate(\"geometry\") %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wt = st_inverse_distance(nb, geometry,\n                                  scale = 1,\n                                  alpha = 1),\n         .before = 1) %>%\n  set_nbs(\"nb\") %>%\n  set_wts(\"wt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#if (!inherits(GDPPC_nb$nb[[1]], \"nb\")) {\n  #stop(\"nb is not a valid neighbors list. Check its computation.\")\n#}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(GDPPC_nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   Year County  GDPPC nb        wt       \n  <dbl> <chr>   <dbl> <list>    <list>   \n1  2005 Anxiang  8184 <int [6]> <dbl [6]>\n2  2005 Hanshou  6560 <int [6]> <dbl [6]>\n3  2005 Jinshi   9956 <int [5]> <dbl [5]>\n4  2005 Li       8394 <int [5]> <dbl [5]>\n5  2005 Linli    8850 <int [5]> <dbl [5]>\n6  2005 Shimen   9244 <int [6]> <dbl [6]>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngi_stars <- GDPPC_nb %>% \n  group_by(Year) %>% \n  mutate(gi_star = local_gstar_perm(\n    GDPPC, nb, wt)) %>% \n  tidyr::unnest(gi_star)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#gi_stars <- Incidents_nb %>% \n  #group_by(year) %>% \n  #mutate(gi_star = local_gstar_perm(\n    #Incidents, nb, wt)) %>% \n  #tidyr::unnest(gi_star)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}